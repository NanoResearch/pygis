from pylab import *
import pygis.raster
import pygis.mh
import numpy as np
import scipy.special as sps
import scipy.stats as stats

# BNG co-ords of Stonehenge and Avebury
stonehenge=(412245, 142195)
avebury=(410235, 169965)

# Load the elevation data
elev = pygis.raster.open_raster('dtm21.tif')
grad = pygis.raster.elevation_gradient(elev)

# Specify initial path
start_path=elev.proj_to_linear((stonehenge, avebury))
start_cost=pygis.mh.path_cost(start_path, grad)
current = (start_path, start_cost)
best = (start_path, start_cost)

def path_elevations(elev, points):
    e = None
    dists = None
    step = np.array(elev.pixel_linear_shape).min()
    for start, end in zip(points[:-1], points[1:]):
        ps, ds = pygis.path.points_on_line(start, end, step)
        es = elev.lanczos_sample(ps)
        if e is None:
            e = es
            dists = ds
        else:
            e = hstack((e, es))
            dists = hstack((dists, dists[-1] + ds))
    return dists, e

def plot_state():
    figure(1)
    clf()

    subplot(211)
    pygis.raster.show_raster(elev, cmap=cm.gray)
    plot(stonehenge[0], stonehenge[1], '.r', scalex=False, scaley=False)
    plot(avebury[0], avebury[1], '.r', scalex=False, scaley=False)

    a = array(start_path)
    plot(a[:,0], a[:,1], scalex=False, scaley=False)
    a = array(current[0])
    plot(a[:,0], a[:,1], scalex=False, scaley=False)
    a = array(best[0])
    plot(a[:,0], a[:,1], scalex=False, scaley=False)

    subplot(212)
    plot(*path_elevations(elev, start_path))
    plot(*path_elevations(elev, current[0]))
    plot(*path_elevations(elev, best[0]))

def path_distances(path):
    distances = [0.0]
    for start, end in zip(path[:-1], path[1:]):
        delta = end - start
        distances.append(np.sqrt(np.vdot(delta, delta)))
    return np.array(distances)

def split_path(path, distance):
    path = array(path)

    distances = path_distances(path)
    end = find(distances > distance)[0]
    start = end - 1
    assert start >= 0
    assert end < len(path)

    left = path[:end,:]
    right = path[end:,:]

    alpha = (distance - distances[start]) / (distances[end] - distances[start])
    mid = path[start] + alpha * (path[end]-path[start])

    left = vstack((left, [mid,]))
    right = vstack(([mid,], right))

    return left, right

def replace_path(path):
    log_forward = 0.0
    log_backward = 0.0
    braveness = 0.5

    assert len(path) >= 2
    delta = path[-1] - path[0]
    line_dist = np.sqrt(np.dot(delta, delta))

    l = 2
    n_internal_points = np.random.poisson(l)
    log_forward += stats.poisson.logpmf(n_internal_points, l)
    step = line_dist / (n_internal_points + 1)
    new_path, _ = pygis.path.points_on_line(path[0], path[-1], step)
    for idx in range(1, 1+n_internal_points):
        dp = np.random.randn(2) * step * braveness
        new_path[idx] += dp
        log_forward += stats.norm.logpdf(dp, 0, step * braveness).sum()

    # calculate lik of replacing this path with the original path
    n_orig_internal_points = len(path) - 2
    log_backward += stats.poisson.logpmf(n_orig_internal_points, l)

    step = line_dist / (n_orig_internal_points + 1)
    line_p, _ = pygis.path.points_on_line(path[0], path[-1], step)
    for idx in range(1, 1+n_orig_internal_points):
        dp = path[idx] - line_p[idx]
        log_backward += stats.norm.logpdf(dp, 0, step * braveness).sum()

    return new_path, log_forward, log_backward

def replace_subset_of_path(path):
    log_forward = 0.0
    log_backward = 0.0
    new_path = path

    distances = path_distances(path)
    d1 = uniform() * distances[-1]
    start = find(distances >= d1)[0]-1
    d2 = uniform() * (distances[-1] - d1) + d1
    end = find(distances >= d2)[0]

    subset = path[start:end+1]
    if len(subset) < 2:
        print(subset)
        assert False
    new_subset, sf, sb = replace_path(subset)
    log_forward += sf
    log_backward += sb

    #log_backward += 2.0 * -np.log(len(new_path))

    path = list(path)
    new_path = path[:start] + new_subset + path[end+1:]

    return new_path, log_forward, log_backward

def sample_segment(path):
    start_idx = np.random.randint(0, len(path)-1)
    end_idx = start_idx + 1
    lik = -np.log(len(path)-1)
    return start_idx, end_idx, lik

def mutate_path(path):
    log_forward = 0.0
    log_backward = 0.0
    new_path = path

    move = np.random.randint(1,3)

    if move == 0:
        # replace path subset
        #new_path, log_forward, log_backward = replace_subset_of_path(path)

        # noise a point
        if len(path) <= 2:
            return new_path, log_forward, log_backward

        idx = np.random.randint(1, len(path)-1)

        d1 = path[idx] - path[idx-1]
        d1 = np.sqrt(np.dot(d1,d1))
        d2 = path[idx+1] - path[idx]
        d2 = np.sqrt(np.dot(d2,d2))
        sigma = 0.5 * (d1 + d2) * 0.25

        dp = randn(2) * sigma

        new_path = list(path)
        new_path[idx] = new_path[idx] + dp

    elif move == 1:
        # add a new waypoint
        start_idx, end_idx, lik = sample_segment(path)
        log_forward += lik

        start = path[start_idx]
        end = path[end_idx]
        new_p = (end+start) * 0.5

        d = end - start
        d = np.sqrt(np.dot(d,d))
        sigma = d * 0.25
        dp = randn(2) * sigma
        new_p += dp
        log_forward += stats.norm.logpdf(dp, 0, sigma).sum()

        path = list(path)
        new_path = path[:end_idx] + [new_p,] + path[end_idx:]

        # reverse is choosing this point to delete
        log_backward += -log(len(new_path)-2)
    elif move == 2:
        # remove a waypoint
        if len(path) <= 2:
            return new_path, log_forward, log_backward

        # where?
        del_idx = np.random.randint(1, len(path)-1)
        log_forward += -log(len(path)-2)

        path = list(path)
        del_p = path[del_idx]
        new_path = path[:del_idx] + path[del_idx+1:]

        # prob of adding it back
        log_backward += -log(len(new_path)-1)

        start = path[del_idx-1]
        end = path[del_idx]
        midp = (end+start) * 0.5

        d = end - start
        d = np.sqrt(np.dot(d,d))
        sigma = d * 0.25
        dp = del_p - midp
        log_backward += stats.norm.logpdf(dp, 0, sigma).sum()
    else:
        assert False

    return new_path, log_forward, log_backward

def sample(path, cost, grad):
    # propose path
    new_path, log_forward, log_inv = mutate_path(path)
    new_cost = pygis.mh.path_cost(new_path, grad)

    log_alpha = log_inv - log_forward

    l = 1.0
    log_p_new = log(l) - l * new_cost
    log_p_old = log(l) - l * cost
    log_alpha += log_p_new - log_p_old

    log_p_new -= len(new_path)
    log_p_old -= len(path)

    alpha = exp(log_alpha)
    if np.random.uniform() < alpha:
        return new_path, new_cost
    else:
        return path, cost

def tick(its=10):
    global current, best
    for i in range(its):
        current = sample(current[0], current[1], grad)
        if current[1] < best[1]:
            best = current
        if i % 10 == 0:
            print('current: %s, best: %s' % (current[1], best[1]))

tick()
plot_state()

# vim:filetype=python:sw=4:sts=4:et

