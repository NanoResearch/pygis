import pygis.raster
import pygis.mh
import numpy as np
import scipy.stats as stats

import path_planning
reload(path_planning)

# BNG co-ords of Stonehenge and Avebury
stonehenge=(412245, 142195)
avebury=(410235, 169965)

# Load the elevation data
elev = pygis.raster.open_raster('dtm21.tif')
grad = pygis.raster.elevation_gradient(elev)

# Specify initial path
start_path=elev.proj_to_linear((stonehenge, avebury))

def plot_paths(paths):
    figure(1)
    clf()

    pygis.raster.show_raster(elev, cmap=cm.gray)
    plot(stonehenge[0], stonehenge[1], '.r', scalex=False, scaley=False)
    plot(avebury[0], avebury[1], '.r', scalex=False, scaley=False)

    for p in paths:
        a = array(p)
        plot(a[:,0], a[:,1], scalex=False, scaley=False)

def path_elevations(elev, points):
    e = None
    dists = None
    step = np.array(elev.pixel_linear_shape).min()
    for start, end in zip(points[:-1], points[1:]):
        ps, ds = pygis.path.points_on_line(start, end, step)
        es = elev.lanczos_sample(ps)
        if e is None:
            e = es
            dists = ds
        else:
            e = hstack((e, es))
            dists = hstack((dists, dists[-1] + ds))
    return dists, e

class Sampler(object):
    def __init__(self, start_path, grad):
        self.start_path = start_path
        self.grad = grad

        self.current = (path_planning.Path(start_path), pygis.mh.path_cost(start_path, grad))
        self.best = (path_planning.Path(start_path), pygis.mh.path_cost(start_path, grad))
        self.it_count = 0

        self.accepts = 0
        self.samples = 0

    def sample(self):
        # propose path
        new_path, log_forward, log_inv = path_planning.propose(self.current[0])
        #print(log_forward, log_inv)
        new_cost = pygis.mh.path_cost(new_path.points, self.grad)

        log_alpha = log_inv - log_forward

        l = 1.0
        log_p_new = log(l) - l * new_cost
        log_p_old = log(l) - l * self.current[1]
        log_alpha += log_p_new - log_p_old

        self.samples += 1
        alpha = exp(log_alpha)
        if np.random.uniform() < alpha:
            self.accepts += 1
            self.current = (new_path, new_cost)

        if self.current[1] < self.best[1]:
            self.best = self.current
        
        return self.current

def tick(state, its=10, quiet=False):
    for i in range(its):
        state.sample()

        if not quiet and i % 10 == 0:
            print('alpha: %.3f, current: %.1f, best: %.1f' % \
                    (float(state.accepts) / state.samples, state.current[1], state.best[1]))

    if state.samples > 0:
        print('after %i iterations, alpha: %.3f, current: %.1f, best: %.1f' % \
                (state.samples, float(state.accepts) / state.samples, state.current[1], state.best[1]))

def run(state, its=100, **kwargs):
    tick(state, its, **kwargs)
    plot_paths([start_path, state.current[0].points, state.best[0].points])

state = Sampler(start_path, grad)
run(state, 0)

sampled_paths = []
def sample_path():
    state = Sampler(start_path, grad)
    for i in xrange(500):
        state.sample()
    print('after %i iterations, alpha: %.3f, current: %.1f, best: %.1f' % \
            (state.samples, float(state.accepts) / state.samples, state.current[1], state.best[1]))
    sampled_paths.append(state.current)
    plot_paths([start_path,] + [x[0].points for x in sampled_paths])

# vim:filetype=python:sw=4:sts=4:et

