import pygis.raster
import pygis.mh
import numpy as np
import scipy.stats as stats

import path_planning
reload(path_planning)

# BNG co-ords of Stonehenge and Avebury
stonehenge=(412245, 142195)
avebury=(410235, 169965)

# Load the elevation data
elev = pygis.raster.open_raster('dtm21.tif')
grad = pygis.raster.elevation_gradient(elev)

# Specify initial path
start_path=elev.proj_to_linear((stonehenge, avebury))

def plot_paths(paths):
    figure(1)
    clf()

    pygis.raster.show_raster(elev, cmap=cm.gray)
    plot(stonehenge[0], stonehenge[1], '.r', scalex=False, scaley=False)
    plot(avebury[0], avebury[1], '.r', scalex=False, scaley=False)

    for p in paths:
        a = array(p)
        plot(a[:,0], a[:,1], scalex=False, scaley=False)

def path_elevations(elev, points):
    e = None
    dists = None
    step = np.array(elev.pixel_linear_shape).min()
    for start, end in zip(points[:-1], points[1:]):
        ps, ds = pygis.path.points_on_line(start, end, step)
        es = elev.lanczos_sample(ps)
        if e is None:
            e = es
            dists = ds
        else:
            e = hstack((e, es))
            dists = hstack((dists, dists[-1] + ds))
    return dists, e

accepts = 0
samples = 0
def sample(path, cost, grad):
    global accepts, samples

    # propose path
    new_path, log_forward, log_inv = path_planning.propose(path)
    #print(log_forward, log_inv)
    new_cost = pygis.mh.path_cost(new_path.points, grad)

    log_alpha = log_inv - log_forward

    l = 1.0
    log_p_new = log(l) - l * new_cost
    log_p_old = log(l) - l * cost
    log_alpha += log_p_new - log_p_old

    samples += 1
    alpha = exp(log_alpha)
    if np.random.uniform() < alpha:
        accepts += 1
        return new_path, new_cost
    else:
        return path, cost

current = (path_planning.Path(start_path), pygis.mh.path_cost(start_path, grad))
best = (path_planning.Path(start_path), pygis.mh.path_cost(start_path, grad))
it_count = 0
def tick(its=10):
    global current, best, it_count
    for i in range(its):
        current = sample(current[0], current[1], grad)
        if current[1] < best[1]:
            best = current
        if i % 10 == 0:
            print('alpha: %.3f, current: %.1f, best: %.1f' % (float(accepts) / samples, current[1], best[1]))
        it_count += 1

def run(its=100):
    tick(its)
    plot_paths([start_path, current[0].points, best[0].points])

run(0)

# vim:filetype=python:sw=4:sts=4:et

